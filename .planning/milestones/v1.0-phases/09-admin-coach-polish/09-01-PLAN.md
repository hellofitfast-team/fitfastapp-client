---
phase: 09-admin-coach-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/pwa/OneSignalProvider.tsx
  - src/hooks/use-notifications.ts
  - src/app/[locale]/(dashboard)/settings/page.tsx
  - src/messages/en.json
  - src/messages/ar.json
autonomous: true

must_haves:
  truths:
    - "OneSignal initialization failures are logged to Sentry with feature/integration tags"
    - "OneSignal initialization error state is accessible to downstream consumers via React context"
    - "Dashboard settings page shows disabled notification UI with info message when OneSignal fails"
    - "use-notifications hook logs errors to Sentry instead of silently catching them"
  artifacts:
    - path: "src/components/pwa/OneSignalProvider.tsx"
      provides: "OneSignal error context provider"
      contains: "Sentry.captureException"
    - path: "src/hooks/use-notifications.ts"
      provides: "Notification hook with error state from OneSignal context"
      contains: "Sentry.captureException"
    - path: "src/app/[locale]/(dashboard)/settings/page.tsx"
      provides: "Disabled notification UI with info message on OneSignal failure"
      contains: "notifications.unavailable"
  key_links:
    - from: "src/components/pwa/OneSignalProvider.tsx"
      to: "@sentry/nextjs"
      via: "captureException in catch block"
      pattern: "Sentry\\.captureException.*onesignal"
    - from: "src/hooks/use-notifications.ts"
      to: "src/components/pwa/OneSignalProvider.tsx"
      via: "React context consumption"
      pattern: "useOneSignalError|useContext.*OneSignal"
    - from: "src/app/[locale]/(dashboard)/settings/page.tsx"
      to: "src/hooks/use-notifications.ts"
      via: "error prop from hook"
      pattern: "error.*useNotifications"
---

<objective>
Add OneSignal graceful degradation with Sentry logging and user-facing error state.

Purpose: When OneSignal initialization fails (ad blockers, network issues, missing config), the user sees a clear info message with disabled notification UI instead of a broken toggle. All OneSignal errors are logged to Sentry with context for debugging.

Output: OneSignalProvider exports error state via context, use-notifications exposes it, settings page renders disabled UI.
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-admin-coach-polish/09-RESEARCH.md
@src/components/pwa/OneSignalProvider.tsx
@src/hooks/use-notifications.ts
@src/app/[locale]/(dashboard)/settings/page.tsx
@src/app/[locale]/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: OneSignal error context + Sentry logging</name>
  <files>
    src/components/pwa/OneSignalProvider.tsx
    src/hooks/use-notifications.ts
  </files>
  <action>
1. **OneSignalProvider.tsx** -- Create a React context to expose OneSignal initialization error state:
   - Create `OneSignalErrorContext` with `React.createContext<Error | null>(null)`
   - Export `useOneSignalError` hook that calls `useContext(OneSignalErrorContext)`
   - Add `useState<Error | null>(null)` for `initError`
   - In the `.catch()` block (after the "already initialized" filter):
     - Log to Sentry: `Sentry.captureException(err, { tags: { feature: "push-notifications", integration: "onesignal" }, extra: { appId: appId ? "present" : "missing", environment: process.env.NODE_ENV } })`
     - Set `initError` state
   - Wrap `{children}` pattern: Change from returning `null` to accepting `children` prop and wrapping in `<OneSignalErrorContext.Provider value={initError}>{children}</OneSignalErrorContext.Provider>`
   - Update the root layout (`src/app/[locale]/layout.tsx`) to pass `{children}` to `<OneSignalProvider>` -- the provider currently returns null and renders no children. Change it to wrap `{children}` (the rest of the app) OR keep it returning null and use a separate context provider. The simpler approach: keep OneSignalProvider returning null but export the context separately. Use a module-level variable instead of context since OneSignalProvider renders no children:
     - Actually, the cleanest pattern: Create a separate context file is overkill. Instead, use a module-scoped observable pattern:
       - Export `let oneSignalInitError: Error | null = null` and a `subscribeToOneSignalError(callback)` function
       - OR simpler: just add an `error` field to the `useNotifications` hook by having it dynamically import and check OneSignal state
     - **Recommended approach (simplest, no context needed):** In `use-notifications.ts`, wrap the `checkSubscription` and `toggleSubscription` OneSignal calls in try-catch that catches OneSignal-not-initialized errors and sets a new `error` state. The hook already dynamically imports OneSignal -- if OneSignal.init failed, these calls will throw. Catch those errors, set `error` state, log to Sentry.

   **Final decision for OneSignalProvider.tsx:**
   - Add `import * as Sentry from "@sentry/nextjs"`
   - In the `.catch()` block, replace `console.error("OneSignal init failed:", err)` with Sentry logging:
     ```
     Sentry.captureException(err instanceof Error ? err : new Error(String(err)), {
       tags: { feature: "push-notifications", integration: "onesignal" },
       extra: { appId: appId ? "present" : "missing", environment: process.env.NODE_ENV },
     });
     ```
   - Keep returning null (no context wrapping needed)

2. **use-notifications.ts** -- Add `error` state and Sentry logging:
   - Add `import * as Sentry from "@sentry/nextjs"`
   - Add `const [error, setError] = useState<string | null>(null)` state
   - In `checkSubscription()` catch block (line 33): Replace empty catch with:
     ```
     setIsSubscribed(Notification.permission === "granted");
     setError("onesignal_unavailable");
     Sentry.captureException(err instanceof Error ? err : new Error("OneSignal subscription check failed"), {
       tags: { feature: "push-notifications", operation: "check-subscription" },
     });
     ```
   - In `requestPermission()` catch block (line 58): Replace empty catch with:
     ```
     Sentry.captureException(err instanceof Error ? err : new Error("Permission request failed"), {
       tags: { feature: "push-notifications", operation: "request-permission" },
     });
     ```
   - In `toggleSubscription()` catch block (line 92): Replace empty catch with:
     ```
     Sentry.captureException(err instanceof Error ? err : new Error("Toggle subscription failed"), {
       tags: { feature: "push-notifications", operation: "toggle-subscription" },
     });
     ```
   - For the three `.catch(() => {})` fire-and-forget OneSignal sync calls (lines 56, 67, 79, 89): Replace with `.catch((err) => { Sentry.captureException(err, { tags: { feature: "push-notifications", operation: "onesignal-sync" }, level: "warning" }); })` -- these are best-effort so use warning level, not error
   - Add `error` to the return object: `return { isSupported, permission, isSubscribed, requestPermission, toggleSubscription, loading, error }`
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify no type errors. Grep for `console.error` in both files to confirm none remain (all replaced with Sentry). Grep for `.catch(() => {})` in use-notifications.ts to confirm none remain.
  </verify>
  <done>
    OneSignalProvider logs init failures to Sentry with tags. use-notifications exposes `error` state and logs all caught errors to Sentry. No silent error swallowing remains in either file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings page disabled notification UI + i18n</name>
  <files>
    src/app/[locale]/(dashboard)/settings/page.tsx
    src/messages/en.json
    src/messages/ar.json
  </files>
  <action>
1. **i18n keys** -- Add notification unavailable messages to both language files under the existing `settings` namespace:
   - `en.json` > `settings`: Add:
     - `"notificationsUnavailableTitle": "Notifications Unavailable"`
     - `"notificationsUnavailableDescription": "Push notifications could not be initialized. This may be caused by an ad blocker or browser settings."`
   - `ar.json` > `settings`: Add:
     - `"notificationsUnavailableTitle": "الإشعارات غير متاحة"`
     - `"notificationsUnavailableDescription": "تعذر تهيئة الإشعارات. قد يكون السبب أداة حظر الإعلانات أو إعدادات المتصفح."`

2. **settings/page.tsx** -- Show disabled notification UI when OneSignal error exists:
   - Destructure `error` from `useNotifications()`: `const { isSupported, isSubscribed, permission, toggleSubscription, loading: notifLoading, error: notifError } = useNotifications()`
   - Add `import { AlertTriangle } from "lucide-react"` (already imported in other files, check if already present)
   - In the Notifications section (around line 210-262), add a conditional block BEFORE the existing toggle UI. When `notifError` is truthy:
     ```tsx
     {notifError ? (
       <div className="border-4 border-black bg-amber-50 p-4">
         <div className="flex items-start gap-3">
           <div className="flex h-10 w-10 shrink-0 items-center justify-center bg-amber-500">
             <AlertTriangle className="h-5 w-5 text-black" strokeWidth={3} />
           </div>
           <div className="space-y-1">
             <p className="font-black text-sm uppercase text-amber-900">
               {t("notificationsUnavailableTitle")}
             </p>
             <p className="font-mono text-xs text-amber-700">
               {t("notificationsUnavailableDescription")}
             </p>
           </div>
         </div>
       </div>
     ) : (
       /* existing toggle + reminder time UI */
     )}
     ```
   - The existing toggle and reminder time controls should be wrapped in the else branch. When notifications are unavailable, the toggle and reminder time should NOT be shown (they won't work anyway).
   - Use brutalist styling consistent with the codebase: border-4, font-black, uppercase for title, font-mono for description. Use amber colors for warning state (consistent with the toast warning patterns).
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify no type errors. Check that the settings page renders correctly by running `pnpm build` (or at minimum `pnpm tsc --noEmit`). Verify i18n keys exist in both en.json and ar.json by grepping for "notificationsUnavailable".
  </verify>
  <done>
    When OneSignal initialization fails, the dashboard settings page shows a visible amber warning box with "Notifications Unavailable" title and descriptive text explaining possible causes. The notification toggle and reminder time controls are hidden. Both English and Arabic translations are provided.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with no errors
2. `grep -r "console.error" src/components/pwa/OneSignalProvider.tsx` returns no matches
3. `grep -r "catch(() => {})" src/hooks/use-notifications.ts` returns no matches
4. `grep -r "Sentry.captureException" src/components/pwa/OneSignalProvider.tsx` returns at least 1 match
5. `grep -r "Sentry.captureException" src/hooks/use-notifications.ts` returns at least 3 matches
6. `grep -r "notificationsUnavailable" src/messages/en.json src/messages/ar.json` returns matches in both files
7. `grep -r "notifError" src/app/[locale]/(dashboard)/settings/page.tsx` returns matches
</verification>

<success_criteria>
- OneSignal init failures logged to Sentry with feature/integration tags (not console.error)
- All silent catches in use-notifications.ts replaced with Sentry logging
- use-notifications returns `error` field
- Settings page shows amber warning box when notifications unavailable
- Notification toggle hidden when error exists
- i18n keys in both English and Arabic
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-coach-polish/09-01-SUMMARY.md`
</output>
