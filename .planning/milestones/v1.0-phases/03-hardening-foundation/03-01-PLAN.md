---
phase: 03-hardening-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/errors/types.ts
  - src/lib/errors/retry.ts
  - src/lib/errors/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Custom error classes support instanceof checks correctly (Object.setPrototypeOf pattern)"
    - "withRetry wraps any async function with exponential backoff (1s, 2s, 4s) and full jitter"
    - "All retries exhausted produces a RetryError with attempt count and last error"
    - "Each retry attempt logs a warning to Sentry with operation name and attempt number"
    - "All error classes and retry utility have JSDoc comments for IDE autocomplete"
  artifacts:
    - path: "src/lib/errors/types.ts"
      provides: "AppError, ValidationError, RetryError, AIGenerationError classes"
      contains: "Object.setPrototypeOf"
    - path: "src/lib/errors/retry.ts"
      provides: "withRetry async utility"
      exports: ["withRetry"]
      contains: "backOff"
    - path: "src/lib/errors/index.ts"
      provides: "Barrel re-exports for all error infrastructure"
      exports: ["AppError", "ValidationError", "RetryError", "AIGenerationError", "withRetry"]
  key_links:
    - from: "src/lib/errors/retry.ts"
      to: "src/lib/errors/types.ts"
      via: "import RetryError"
      pattern: "import.*RetryError.*from.*types"
    - from: "src/lib/errors/retry.ts"
      to: "exponential-backoff"
      via: "npm dependency"
      pattern: "import.*backOff.*from.*exponential-backoff"
---

<objective>
Create the error infrastructure foundation: custom domain error classes and an exponential backoff retry utility.

Purpose: Phase 4 (Service Layer) and Phase 5 (API Routes) will import these utilities to wrap AI calls, Supabase queries, and JSON.parse operations. Building them as standalone, well-typed modules now ensures consistent error handling across the entire hardening effort.

Output: `src/lib/errors/` directory with types.ts (error classes), retry.ts (backoff wrapper), and index.ts (barrel exports).
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hardening-foundation/03-RESEARCH.md
@src/lib/ai/openrouter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install exponential-backoff and create custom error classes</name>
  <files>package.json, src/lib/errors/types.ts</files>
  <action>
1. Install the exponential-backoff package:
   ```bash
   pnpm install exponential-backoff
   ```

2. Create `src/lib/errors/types.ts` with four error classes, all following the Object.setPrototypeOf pattern for proper instanceof checks:

   - **AppError** (base class): Extends Error. Constructor takes `message: string`, optional `code?: string`, optional `context?: Record<string, unknown>`. Sets `this.name = this.constructor.name`. Calls `Object.setPrototypeOf(this, new.target.prototype)` and `Error.captureStackTrace(this, this.constructor)` (guard with `if` since captureStackTrace is V8-only).

   - **ValidationError**: Extends AppError. Constructor takes `message: string` and optional `zodError?: ZodError` (import ZodError type from zod). Sets code to "VALIDATION_ERROR". Stores zodError as public property. Include a getter `get issues()` that returns `this.zodError?.issues ?? []` for easy access to validation details.

   - **RetryError**: Extends AppError. Constructor takes `message: string`, `lastError: Error`, `attempts: number`. Sets code to "RETRY_EXHAUSTED". Stores both as public properties. Include context with lastError.message and attempts count.

   - **AIGenerationError**: Extends AppError. Constructor takes `message: string`, `provider: string`, optional `originalError?: Error`. Sets code to "AI_GENERATION_FAILED". Stores provider and originalError as public properties. Include context with provider and originalError?.message.

   Every class must have JSDoc comments explaining when to use it and what Phase 4/5 consumers should expect. Export all four classes.
  </action>
  <verify>
Run `pnpm tsc --noEmit` to confirm no TypeScript errors. Verify exponential-backoff is in package.json dependencies. Verify src/lib/errors/types.ts exists and exports all four classes.
  </verify>
  <done>Four custom error classes exist with proper prototype chain, JSDoc documentation, and full TypeScript types. exponential-backoff package installed.</done>
</task>

<task type="auto">
  <name>Task 2: Create retry utility and barrel exports</name>
  <files>src/lib/errors/retry.ts, src/lib/errors/index.ts</files>
  <action>
1. Create `src/lib/errors/retry.ts` with a `withRetry` generic async function:

   ```typescript
   import { backOff } from "exponential-backoff";
   import { RetryError } from "./types";
   import * as Sentry from "@sentry/nextjs";
   ```

   **Function signature:**
   ```typescript
   export async function withRetry<T>(
     operation: () => Promise<T>,
     options?: {
       maxAttempts?: number;       // default: 3
       operationName?: string;     // default: "operation" - used in logs
       shouldRetry?: (error: Error) => boolean;  // default: always retry
     }
   ): Promise<T>
   ```

   **Implementation details:**
   - Track `lastError` in closure scope (updated on each retry callback)
   - Call `backOff(operation, { ... })` with these options:
     - `numOfAttempts`: from options.maxAttempts (default 3)
     - `startingDelay`: 1000 (1 second)
     - `timeMultiple`: 2 (exponential: 1s, 2s, 4s)
     - `maxDelay`: 5000 (cap at 5 seconds)
     - `jitter`: "full" (prevent thundering herd)
     - `retry`: callback that (a) updates lastError, (b) logs to Sentry as warning with operationName and attemptNumber, (c) calls shouldRetry if provided (return false to stop retrying), (d) returns true to continue
   - Wrap backOff call in try-catch. On catch, throw a new `RetryError` with the operationName, lastError, and maxAttempts. Also capture the RetryError to Sentry with level "error" and tags `{ operationName, retryExhausted: "true" }`.
   - Add comprehensive JSDoc with @param, @returns, @throws, and usage example showing OpenRouter wrapping.

2. Create `src/lib/errors/index.ts` as barrel file:
   - Re-export all from "./types": `export { AppError, ValidationError, RetryError, AIGenerationError } from "./types";`
   - Re-export withRetry from "./retry": `export { withRetry } from "./retry";`
   - This lets consumers do `import { withRetry, RetryError } from "@/lib/errors";`
  </action>
  <verify>
Run `pnpm tsc --noEmit` to confirm no TypeScript errors. Verify the barrel file re-exports correctly by checking that all 5 exports (4 classes + withRetry) are present in index.ts.
  </verify>
  <done>withRetry utility wraps any async operation with 1s/2s/4s exponential backoff, full jitter, Sentry logging per attempt, and throws RetryError when exhausted. Barrel exports allow clean imports from "@/lib/errors".</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero errors
2. `exponential-backoff` appears in package.json dependencies
3. All files exist: src/lib/errors/types.ts, src/lib/errors/retry.ts, src/lib/errors/index.ts
4. types.ts exports: AppError, ValidationError, RetryError, AIGenerationError
5. retry.ts exports: withRetry
6. index.ts re-exports all 5 symbols
7. All classes use Object.setPrototypeOf pattern
8. withRetry uses backOff with jitter: "full" and maxDelay: 5000
</verification>

<success_criteria>
- Custom error classes with proper prototype chain and Sentry-friendly context
- Retry utility with exponential backoff (1s/2s/4s), full jitter, configurable attempts, and Sentry logging
- All utilities have JSDoc comments
- Clean barrel imports from "@/lib/errors"
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-hardening-foundation/03-01-SUMMARY.md`
</output>
