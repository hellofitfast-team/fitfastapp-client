---
phase: 08-component-refactoring
plan: 05
type: execute
wave: 2
depends_on: ["08-01", "08-02", "08-03", "08-04"]
files_modified:
  - src/app/[locale]/(dashboard)/check-in/error.tsx
  - src/app/[locale]/(dashboard)/settings/error.tsx
  - src/app/[locale]/(dashboard)/tickets/error.tsx
  - src/app/[locale]/(dashboard)/progress/error.tsx
  - src/app/[locale]/(dashboard)/tracking/error.tsx
  - src/messages/en.json
  - src/messages/ar.json
autonomous: true

must_haves:
  truths:
    - "Route segment error boundaries catch page-level errors without crashing the app shell"
    - "Error boundaries log to Sentry with route-specific tags"
    - "Error boundaries show translated error messages in both en and ar"
    - "Reset button in error boundary allows retry without full page reload"
    - "No client component exceeds 400 lines in the entire dashboard"
  artifacts:
    - path: "src/app/[locale]/(dashboard)/check-in/error.tsx"
      provides: "Check-in route error boundary"
    - path: "src/app/[locale]/(dashboard)/settings/error.tsx"
      provides: "Settings route error boundary"
    - path: "src/app/[locale]/(dashboard)/tickets/error.tsx"
      provides: "Tickets route error boundary"
    - path: "src/app/[locale]/(dashboard)/progress/error.tsx"
      provides: "Progress route error boundary"
    - path: "src/app/[locale]/(dashboard)/tracking/error.tsx"
      provides: "Tracking route error boundary"
  key_links:
    - from: "*/error.tsx"
      to: "@sentry/nextjs"
      via: "Sentry.captureException in useEffect"
      pattern: "Sentry\\.captureException"
    - from: "*/error.tsx"
      to: "src/messages/*.json"
      via: "useTranslations for error messages"
      pattern: "useTranslations.*errors"
---

<objective>
Add route-segment-level error boundaries for the 5 critical dashboard routes and verify the entire phase's success criteria (no component over 400 lines).

Purpose: Currently error boundaries only exist at the root level. A crash in check-in, settings, or tickets takes down the entire app shell. Route segment error boundaries isolate failures so users can retry without losing their dashboard context.

Output: 5 new error.tsx files with Sentry integration and bilingual error messages. Final verification that all components meet the 400-line threshold.
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-component-refactoring/08-RESEARCH.md
@src/app/[locale]/error.tsx
@src/messages/en.json
@src/messages/ar.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add i18n error keys and create route segment error boundaries</name>
  <files>
    src/messages/en.json
    src/messages/ar.json
    src/app/[locale]/(dashboard)/check-in/error.tsx
    src/app/[locale]/(dashboard)/settings/error.tsx
    src/app/[locale]/(dashboard)/tickets/error.tsx
    src/app/[locale]/(dashboard)/progress/error.tsx
    src/app/[locale]/(dashboard)/tracking/error.tsx
  </files>
  <action>
    1. Add i18n keys to en.json and ar.json under a new "routeErrors" namespace:
       ```json
       "routeErrors": {
         "checkIn": {
           "title": "CHECK-IN ERROR",
           "description": "We couldn't load the check-in form. Please try again.",
           "retry": "TRY AGAIN"
         },
         "settings": {
           "title": "SETTINGS ERROR",
           "description": "We couldn't load your settings. Please try again.",
           "retry": "TRY AGAIN"
         },
         "tickets": {
           "title": "TICKETS ERROR",
           "description": "We couldn't load your tickets. Please try again.",
           "retry": "TRY AGAIN"
         },
         "progress": {
           "title": "PROGRESS ERROR",
           "description": "We couldn't load your progress data. Please try again.",
           "retry": "TRY AGAIN"
         },
         "tracking": {
           "title": "TRACKING ERROR",
           "description": "We couldn't load your tracking data. Please try again.",
           "retry": "TRY AGAIN"
         }
       }
       ```
       Add Arabic translations for all keys.

    2. Create each error.tsx following the brutalist design pattern (matching the app's style, NOT the root error.tsx which uses shadcn Card):
       - "use client" directive
       - Import Sentry, useEffect, useTranslations, AlertTriangle from lucide-react
       - Props: `{ error: Error & { digest?: string }, reset: () => void }`
       - useEffect logs to Sentry with route-specific tags: `{ feature: "check-in-page", route: "/check-in" }`
       - UI: Centered container with brutalist borders (border-4 border-black), AlertTriangle icon in error-500 bg, translated title/description, error digest display, retry button with primary bg
       - Each error.tsx should be ~40-50 lines

    3. The 5 error.tsx files should follow the EXACT same pattern, differing only in:
       - Sentry tags (feature name and route path)
       - Translation namespace key (routeErrors.checkIn, routeErrors.settings, etc.)
       - Icon container color (use error-500 for all — consistency)

    Use brutalist styling to match the app: border-4 border-black, bg-cream, shadow-[8px_8px_0px_0px_rgba(0,0,0,1)], font-black uppercase text, NOT shadcn Card components.

    After creating all files, run `pnpm tsc --noEmit` and `pnpm build` to verify.
  </action>
  <verify>
    All error boundaries exist:
    - `ls src/app/[locale]/(dashboard)/check-in/error.tsx`
    - `ls src/app/[locale]/(dashboard)/settings/error.tsx`
    - `ls src/app/[locale]/(dashboard)/tickets/error.tsx`
    - `ls src/app/[locale]/(dashboard)/progress/error.tsx`
    - `ls src/app/[locale]/(dashboard)/tracking/error.tsx`
    `pnpm tsc --noEmit` passes.
    `pnpm build` succeeds.
  </verify>
  <done>5 route segment error boundaries created with Sentry logging, bilingual messages, and brutalist design</done>
</task>

<task type="auto">
  <name>Task 2: Final verification - no client component exceeds 400 lines</name>
  <files></files>
  <action>
    Run a comprehensive line count check across all client components in the dashboard and onboarding:

    1. Count lines for all .tsx files in:
       - `src/app/[locale]/(dashboard)/**/page.tsx`
       - `src/app/[locale]/(onboarding)/**/page.tsx`
       - `src/app/[locale]/(dashboard)/**/_components/*.tsx`
       - `src/app/[locale]/(onboarding)/**/_components/*.tsx`

    2. Flag any file exceeding 400 lines.

    3. If any file exceeds 400 lines (unlikely but possible for edge cases):
       - Evaluate: Is it cohesive? (per research pitfall 5 — don't split mechanically)
       - If genuinely too large, do a targeted inline split
       - If cohesive, note as acceptable

    4. Verify the overall phase success criteria:
       - No client component > 400 lines (measured via wc -l)
       - _components/ directories exist for check-in, initial-assessment, tracking, progress
       - Error boundaries exist at 5 route segments
       - useCheckInLock hook exists in src/hooks/

    This is a verification + cleanup task. If everything passes, simply document the results.
  </action>
  <verify>
    `find src/app/[locale] -name "page.tsx" -exec wc -l {} + | sort -rn` — no page.tsx exceeds 400 lines.
    `find src/app/[locale] -name "_components" -type d` shows at least 4 directories.
  </verify>
  <done>All client components verified under 400 lines, all _components/ directories created, all error boundaries in place</done>
</task>

</tasks>

<verification>
- 5 error.tsx files exist in dashboard route segments
- i18n keys exist in both en.json and ar.json for routeErrors
- No client component in dashboard or onboarding exceeds 400 lines
- `pnpm tsc --noEmit` passes
- `pnpm build` succeeds
</verification>

<success_criteria>
- Route segment error boundaries catch and display errors without crashing app shell
- Error boundaries log to Sentry with route-specific context
- Both English and Arabic error messages available
- Phase 8 success criteria met: no component > 400 lines, hooks extracted, _components/ used, error boundaries at route segments
</success_criteria>

<output>
After completion, create `.planning/phases/08-component-refactoring/08-05-SUMMARY.md`
</output>
