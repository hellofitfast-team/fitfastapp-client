# Phase 11.1: Auth, Authorization, and Marketing Landing Page — Research

**Researched:** 2026-02-20
**Domain:** Clerk auth flows, Convex integration, Next.js monorepo app scaffolding, marketing landing page
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Marketing Page Design**
- Page must feel natural and consistent with the client app — same royal blue theme, same design language. It's the front door to the product, not a separate marketing site.
- Sections: Hero → Feature highlights (AI plans, check-ins, tracking) → Pricing → Trust signals/testimonials
- Bilingual (EN + AR) using same next-intl setup as client app, with RTL support and language switcher
- Lives as `apps/marketing/` — 3rd monorepo app

**Checkout & Payment Flow**
- Checkout opens as a modal/drawer overlay when user clicks a pricing plan (not a separate page)
- Form fields: name, email, phone number, payment screenshot upload
- Payment screenshot upload: drag-and-drop zone on desktop, tap-to-upload on mobile, with preview before submit
- Payment methods are coach-configurable — coach sets their InstaPay/Vodafone Cash/etc. account details in admin settings, checkout form dynamically displays whatever is configured

**Approval & Onboarding Handoff**
- Full signup flow:
  1. Prospect fills checkout form (name, email, phone, payment screenshot) → stored in Convex as signup record (NO Clerk account yet)
  2. Confirmation page: "Check your email to complete signup"
  3. Clerk magic link email → prospect clicks, sets password → Clerk account created
  4. User lands on pending approval page (logged in but gated) — similar to existing design with status stepper
  5. On approval: Email notification + page auto-transitions to initial assessment (Convex real-time subscription, no manual refresh needed)
  6. On rejection: Email with coach's rejection reason + Clerk account deleted + DB records cleaned up
- Pending page uses Convex real-time subscription — updates instantly when coach makes a decision, no "Check Status" button needed
- Stepper shows: "Signup Complete ✓ → Under Review (current) → Approval Notification (pending)"

**Admin Approval Interface**
- Both list view and detail view for signups
- Table overview with quick Approve button per row
- Click into detail view to inspect payment screenshot closely before approving
- Reject opens a reason input field — reason is included in rejection email to the client

**Pricing Plans & Tiers**
- Plans are coach-configurable from admin settings (not hardcoded)
- Max 4 plans to keep pricing section clean
- Each plan has: name, price, duration, feature bullet list, optional highlight badge ("Most Popular", "Best Value")
- Plans are display-only for pricing — all approved clients get the same features regardless of tier
- Plan data stored in Convex, landing page reads dynamically

### Claude's Discretion
- Pricing card layout style (side-by-side, toggle, etc.)
- Loading skeletons and transition animations
- Exact trust signals / testimonials section design
- Error states and edge case handling
- Marketing page mobile responsive breakpoints
- Approval email template design

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope

</user_constraints>

---

## Summary

Phase 11.1 has three distinct technical sub-problems: (1) scaffolding a 3rd Next.js monorepo app (`apps/marketing/`), (2) implementing the Clerk Invitation flow for post-approval account creation, and (3) fixing admin coach detection to use Clerk `publicMetadata.role` instead of relying on Convex `isCoach` in middleware. The codebase is already well-structured to support all three: Convex already has `pendingSignups` table, `createSignup` mutation, `approveSignup`/`rejectSignup` mutations, Resend email infrastructure, and Convex file storage for payment screenshots. The existing pending page UI pattern also exists and just needs adaptation.

The central design question from CONTEXT.md — "Can Clerk's built-in subscription features handle manual payment verification?" — has a clear answer: **No.** Clerk's subscription features are for Stripe-based automated billing. For the InstaPay/Vodafone Cash manual payment model, the custom Convex-based signup flow is the only viable path. The Clerk Invitation API (`clerkClient.invitations.createInvitation`) is the right tool for the "account creation after coach approval" step: it sends a branded email with a one-time ticket, and the prospect lands on a custom `/accept-invite` page in the client app where they set a password.

The admin coach detection fix is straightforward: update `approveSignup` to call a new Convex action that calls `clerkClient.invitations.createInvitation`, and gate admin middleware on `sessionClaims?.metadata?.role === 'coach'` (stored in Clerk `publicMetadata`) instead of only checking `profile.isCoach` in the layout. The existing layout approach (checking `profile.isCoach` via Convex) remains valid as a defense-in-depth check but the middleware should not blindly trust a Convex query for auth gating.

**Primary recommendation:** Use Clerk Invitation API for account creation on approval, `publicMetadata.role` for RBAC throughout, and scaffold `apps/marketing/` as a lightweight static-ish Next.js app sharing `@fitfast/ui` and `@fitfast/i18n` packages.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@clerk/nextjs` | `^6.37.5` (already installed) | Auth, Clerk Invitation API, role checks | Already in use; `clerkClient()` provides server-side backend API |
| `convex` | `^1.31.7` (already installed) | Data, real-time subscriptions, file storage | Existing backend for all data |
| `next-intl` | `^4.8.2` (already installed) | Bilingual EN/AR with RTL | Shared via `@fitfast/i18n` package |
| `@fitfast/ui` | workspace (already exists) | All UI components, design tokens | Shared package — marketing must use same design language |
| `react-hook-form` + `zod` | existing versions | Checkout form validation | Already in both apps |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `resend` (via Convex action) | existing | Rejection/approval emails | Already used in `convex/email.ts` via `sendWelcomeEmail` |
| `vaul` | `^1.1.2` | Checkout drawer/modal overlay | Already in `@fitfast/ui` — decision is modal/drawer, vaul is the answer |
| `lucide-react` | `^0.563.0` | Icons in marketing page | Consistent with all apps |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Clerk Invitation API | Custom JWT link or Resend magic link | Clerk handles token expiry, one-time use, email branding automatically. Never hand-roll invitation tokens. |
| Vaul drawer for checkout | Radix Dialog | Vaul is already in the stack; drawer feels better on mobile for a payment form |
| Convex `useQuery` for pending real-time | Polling with `setInterval` | Convex subscriptions auto-update — no polling needed, already the existing pattern |

**Installation for `apps/marketing/`:**
```bash
pnpm --filter @fitfast/marketing add next next-intl @clerk/nextjs convex @fitfast/ui @fitfast/i18n lucide-react react-hook-form @hookform/resolvers zod vaul tailwind-merge
pnpm --filter @fitfast/marketing add -D typescript @types/react @types/react-dom tailwindcss @tailwindcss/postcss @fitfast/config
```

---

## Architecture Patterns

### Recommended Project Structure

```
apps/marketing/
├── package.json                    # name: "@fitfast/marketing", port 3002
├── next.config.ts                  # transpilePackages: ["@fitfast/ui", "@fitfast/i18n"]
├── tsconfig.json                   # extends "@fitfast/config/tsconfig.base.json"
├── postcss.config.mjs
├── src/
│   ├── app/
│   │   ├── layout.tsx              # Root layout (no ClerkProvider — marketing is public)
│   │   ├── globals.css             # COPY from apps/client — same design tokens
│   │   └── [locale]/
│   │       ├── layout.tsx          # NextIntlClientProvider + ConvexClientProvider (for pricing query)
│   │       └── page.tsx            # Marketing landing page
│   ├── components/
│   │   ├── sections/
│   │   │   ├── hero.tsx
│   │   │   ├── features.tsx
│   │   │   ├── pricing.tsx         # Reads from Convex systemConfig "pricing" + "plans"
│   │   │   └── testimonials.tsx
│   │   ├── checkout/
│   │   │   ├── checkout-drawer.tsx # Vaul drawer wrapping checkout-form
│   │   │   └── checkout-form.tsx   # React Hook Form + screenshot upload
│   │   └── language-switcher.tsx
│   ├── i18n/
│   │   └── request.ts              # Same pattern as client app
│   └── messages/
│       ├── en.json
│       └── ar.json
└── middleware.ts                   # next-intl only — NO Clerk (fully public)
```

**For `apps/client/src/app/[locale]/` additions:**
```
(auth)/
  accept-invite/
    page.tsx          # NEW: Handles __clerk_ticket query param, signUp.create('ticket')
(onboarding)/
  pending/
    page.tsx          # UPDATE: Remove "Check Status" button, add Convex real-time auto-redirect
```

**For `apps/admin/` additions:**
```
[locale]/(panel)/
  signups/
    [id]/
      page.tsx        # NEW: Signup detail view with payment screenshot display
    signups-table.tsx # UPDATE: Add detail link, reject reason input field
  settings/
    settings-form.tsx # UPDATE: Add payment methods config (Vodafone Cash, etc.)
```

**For `convex/`:**
```
pendingSignups.ts     # UPDATE: approveSignup triggers Clerk invitation, rejectSignup deletes Clerk user
email.ts              # UPDATE: Add sendRejectionEmail with reason
```

---

### Pattern 1: Clerk Invitation Flow (Account Creation After Approval)

**What:** Coach approves a `pendingSignup` in admin panel → Convex action calls Clerk Backend API to create an invitation → Clerk sends email with magic link ticket → Client lands on `/accept-invite?__clerk_ticket=...` → Sets password → Clerk account created → Webhook `user.created` fires → Convex creates profile with `status: "pending_approval"` → Second step: coach's approval in Convex sets `status: "active"`.

**Wait — there is a subtlety here.** The CONTEXT.md flow says: "Clerk magic link email → prospect clicks, sets password → Clerk account created" THEN separately "On approval: page auto-transitions". This means the Clerk invitation is sent RIGHT AWAY after checkout form submission (step 2-3), NOT after coach approval. Coach approval just updates Convex `profile.status` from `pending_approval` to `active`. The Clerk user already exists from step 3 onward.

**Revised flow:**
1. Prospect submits checkout form → `convex/pendingSignups.createSignup` stores the record
2. **Immediately**: A Convex action calls `clerkClient.invitations.createInvitation` with the prospect's email and `redirectUrl: "https://client.fitfast.app/en/accept-invite"`
3. Prospect clicks email link → lands on `/accept-invite?__clerk_ticket=XXX` → sets password → Clerk account created
4. Clerk `user.created` webhook → `convex/http.ts` creates profile with `status: "pending_approval", isCoach: false`
5. Prospect sees pending page (real-time Convex subscription)
6. Coach approves in admin → `convex/pendingSignups.approveSignup` sets signup `status: "approved"` AND patches profile `status: "active"`
7. Convex real-time subscription on the pending page detects `profile.status === "active"` → router.push to `/initial-assessment`
8. On rejection: `rejectSignup` sets reason, calls `clerkClient.users.deleteUser(clerkUserId)`, sends rejection email with reason

**Source:** Clerk Docs — Application Invitations (HIGH confidence, verified via Context7)

```typescript
// convex/pendingSignups.ts — after createSignup, trigger invitation
// This runs as a Convex internalAction (has "use node" — can call Clerk)
export const sendClerkInvitation = internalAction({
  args: {
    email: v.string(),
    fullName: v.string(),
    signupId: v.id("pendingSignups"),
  },
  handler: async (_ctx, { email, fullName, signupId }): Promise<void> => {
    const { createClerkClient } = await import("@clerk/backend");
    const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY! });
    await clerkClient.invitations.createInvitation({
      emailAddress: email,
      redirectUrl: `${process.env.CLIENT_APP_URL}/en/accept-invite`,
      publicMetadata: {
        signupId,      // Link Clerk user back to the signup record
        fullName,
      },
    });
  },
});
```

```typescript
// apps/client/src/app/[locale]/(auth)/accept-invite/page.tsx
"use client";
import { useSignUp, useUser } from "@clerk/nextjs";
import { useSearchParams, useRouter } from "next/navigation";

export default function AcceptInvitePage() {
  const { signUp, setActive, isLoaded } = useSignUp();
  const { isSignedIn } = useUser();
  const router = useRouter();
  const token = useSearchParams().get("__clerk_ticket");

  // Already signed in (post-submit redirect)
  useEffect(() => {
    if (isSignedIn) router.replace("/pending");
  }, [isSignedIn]);

  // No token = direct navigation, redirect away
  if (!token) return <redirect to="/login" />;

  const handleSubmit = async (password: string) => {
    const result = await signUp!.create({
      strategy: "ticket",
      ticket: token,
      password,
    });
    if (result.status === "complete") {
      await setActive!({ session: result.createdSessionId });
      router.replace("/pending"); // Goes to /{locale}/pending
    }
  };
  // ... render password form
}
```

**Source:** Clerk Docs — Custom Application Invitations Flow (HIGH confidence, Context7 verified)

---

### Pattern 2: RBAC with Clerk publicMetadata.role

**What:** Coach's Clerk user gets `publicMetadata.role = "coach"` set once (manually or during seeding). Middleware in admin app checks `sessionClaims?.metadata?.role === "coach"`. Client app checks `sessionClaims?.metadata?.role !== "coach"` to prevent coach accidentally using client PWA.

**Important:** Clerk `publicMetadata` is set from the **Backend API only** (cannot be set from frontend). The admin layout currently checks `profile.isCoach` from Convex — this works fine but is slower (extra DB query). The standard pattern is:
- Middleware: fast check via JWT `sessionClaims.metadata.role`
- Layout: defense-in-depth via Convex profile check (already done)

```typescript
// apps/admin/src/middleware.ts — update
export default clerkMiddleware(async (auth, request: NextRequest) => {
  const path = stripLocale(pathname);
  if (path === "/login") return intlMiddleware(request);

  const { userId, sessionClaims } = await auth();
  const locale = getLocaleFromPath(pathname);

  if (!userId) return NextResponse.redirect(new URL(`/${locale}/login`, origin));

  // Gate admin on Clerk role — fast JWT check, no DB query
  if (sessionClaims?.metadata?.role !== "coach") {
    // Sign them out and redirect to login with error
    return NextResponse.redirect(new URL(`/${locale}/login?error=not_coach`, origin));
  }

  return intlMiddleware(request);
});
```

**Setting the coach role (one-time, at deployment):**
```typescript
// Via Convex action or a setup script
const client = await clerkClient();
await client.users.updateUserMetadata(coachClerkUserId, {
  publicMetadata: { role: "coach" }
});
```

**TypeScript types for session claims:**
```typescript
// apps/admin/src/types/globals.d.ts
export {};
declare global {
  interface CustomJwtSessionClaims {
    metadata: { role?: "coach" | "client" };
  }
}
```

**Source:** Clerk Docs — Basic RBAC guide (HIGH confidence, Context7 verified)

---

### Pattern 3: Convex Real-Time on Pending Page (No Polling)

**What:** The pending page subscribes to `getMyProfile` via `useQuery`. When coach approves and Convex patches the profile, the subscription fires automatically. Page detects `status === "active"` and redirects.

```typescript
// apps/client/src/app/[locale]/(onboarding)/pending/page.tsx
"use client";
import { useQuery } from "convex/react";
import { useConvexAuth } from "convex/react";
import { useRouter } from "next/navigation";
import { api } from "@/convex/_generated/api";
import { useEffect } from "react";

export default function PendingPage() {
  const router = useRouter();
  const { isAuthenticated } = useConvexAuth();
  const profile = useQuery(api.profiles.getMyProfile, isAuthenticated ? {} : "skip");

  useEffect(() => {
    if (profile?.status === "active") {
      router.replace("/initial-assessment"); // real-time redirect
    }
    if (profile?.status === "inactive" || profile?.status === "expired") {
      router.replace("/login?error=rejected");
    }
  }, [profile?.status, router]);

  // ... render stepper UI
}
```

**Note:** The existing pending page already uses this pattern but still has a "Check Status" button with a 1-second delay. The update is: remove the button entirely, trust the reactive subscription. Also update stepper: "Signup Complete → Under Review → Approval Notification" (assessment step is AFTER approval, not listed here).

---

### Pattern 4: Rejection Flow with Clerk User Deletion

**What:** Coach rejects a signup with a reason. The `rejectSignup` mutation/action must:
1. Patch `pendingSignups` record: `status: "rejected"`, store `rejectionReason`
2. Find the Clerk user by email (if they accepted the invitation and created an account)
3. Delete the Clerk user via `clerkClient.users.deleteUser(userId)`
4. The Clerk webhook `user.deleted` fires → `convex/http.ts` deletes the Convex profile
5. Send rejection email with the reason

**Complication:** The coach might reject before the prospect has accepted the invitation (i.e., before Clerk account exists). The action must handle both cases: if no Clerk user exists for that email, skip the deletion step.

```typescript
// convex/pendingSignups.ts (updated rejectSignup — becomes an action with "use node")
export const rejectSignup = action({
  args: {
    signupId: v.id("pendingSignups"),
    rejectionReason: v.string(),
  },
  handler: async (ctx, { signupId, rejectionReason }) => {
    // Auth check via ctx.runQuery(...)
    // ...
    const signup = await ctx.runQuery(internal.helpers.getSignupInternal, { signupId });

    // Patch signup record
    await ctx.runMutation(internal.pendingSignups.patchSignupRejected, {
      signupId, rejectionReason
    });

    // Find Clerk user by email — may not exist yet
    const { createClerkClient } = await import("@clerk/backend");
    const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY! });
    const users = await clerkClient.users.getUserList({ emailAddress: [signup.email] });
    if (users.data.length > 0) {
      await clerkClient.users.deleteUser(users.data[0].id);
      // Webhook user.deleted fires → convex/http.ts deleteProfileFromClerk runs
    }

    // Send rejection email
    await ctx.runAction(internal.email.sendRejectionEmail, {
      email: signup.email,
      fullName: signup.fullName,
      rejectionReason,
      language: "en",
    });
  },
});
```

---

### Pattern 5: Marketing App — Checkout File Upload to Convex

**Problem:** The marketing app is a separate Next.js app. It needs to upload payment screenshots to Convex storage. Convex file upload requires calling `generateUploadUrl` mutation, which requires authentication. The prospect is NOT authenticated at checkout time.

**Solution:** Use a **public Convex mutation** (no auth check) for `generateUploadUrl` scoped to marketing signup context, OR use a Next.js API route that acts as a proxy. The cleaner solution is to add an HTTP action in Convex for unauthenticated upload URL generation, scoped only to payment screenshots.

```typescript
// convex/http.ts — add public upload URL endpoint for marketing
http.route({
  path: "/marketing/upload-url",
  method: "POST",
  handler: httpAction(async (ctx, _request) => {
    const uploadUrl = await ctx.storage.generateUploadUrl();
    return new Response(JSON.stringify({ uploadUrl }), {
      status: 200,
      headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
    });
  }),
});
```

Then the checkout form fetches `POST https://{CONVEX_URL}/marketing/upload-url`, gets the upload URL, `PUT`s the file directly, and records the `storageId` in the checkout form state to submit with `createSignup`.

**Alternative considered:** Make `generateUploadUrl` mutation allow unauthenticated callers conditionally. This is messier because it changes the security posture of an existing mutation. The HTTP action approach is cleaner.

---

### Pattern 6: Pricing Plans in Convex (Coach-Configurable)

The existing `systemConfig` table can store the plan configuration. The current schema stores pricing as:
```json
{ "key": "plan_pricing", "value": { "3_months": 1500, "6_months": 2500, "12_months": 4000 } }
```

This needs expansion to support the new plan model (name, features list, badge, price, duration). A new config key `"plans"` can store a JSON array:
```json
{
  "key": "plans",
  "value": [
    {
      "id": "starter",
      "name": "Starter",
      "nameAr": "المبتدئ",
      "price": 1500,
      "currency": "EGP",
      "duration": "3 months",
      "durationAr": "3 أشهر",
      "features": ["Personalized meal plan", "Workout plan", "Weekly check-ins"],
      "featuresAr": ["خطة وجبات مخصصة", "خطة تمارين", "متابعة أسبوعية"],
      "badge": null,
      "tier": "3_months"
    }
  ]
}
```

The marketing page reads `api.systemConfig.getPricing` (already exists, public query) plus a new `api.systemConfig.getPlans` query. The landing page reads dynamically — no hardcoding.

---

### Pattern 7: Marketing App — No ClerkProvider Needed

The marketing landing page is fully public — no auth required. The `ConvexClientProvider` for pricing queries can use **unauthenticated Convex queries** (Convex public queries work without a Clerk session). The marketing app does NOT need `ClerkProvider` at all, except on the `/accept-invite` page.

**Alternative:** Put the `/accept-invite` route in the client app (`apps/client/`), NOT in `apps/marketing/`. This is cleaner — the client app already has `ClerkProvider`, the `ConvexClientProvider`, and the auth hooks. The marketing app just redirects the Clerk invitation link to the client app's accept page.

**Recommendation:** `/accept-invite` lives in `apps/client/`. The invitation `redirectUrl` points to the client app domain. Marketing app is entirely unauthenticated.

---

### Pattern 8: Admin Signups Detail View

Current signups table (`signups-table.tsx`) expands inline to show payment screenshot + OCR data. The CONTEXT.md requires both a list view (with quick Approve) and a detail view. The detail view is for inspecting the payment screenshot closely.

A new route `apps/admin/src/app/[locale]/(panel)/signups/[id]/page.tsx` handles the detail view. The list shows an "expand" chevron (existing) plus a "View Details" link button that navigates to the detail page.

**Payment screenshot display:** The existing `signups-table.tsx` has `TODO: No screenshot URL in Convex -- would need to resolve from storageId`. This is because `getFileUrl` requires auth and takes a `storageId`. The admin panel IS authenticated so it can call `api.storage.getFileUrl` with the `paymentScreenshotId` from the signup record. The detail page should display this.

---

### Anti-Patterns to Avoid

- **Don't gate admin middleware on Convex DB queries**: Middleware runs on every request. A DB query in middleware is expensive and fragile. Use Clerk JWT `sessionClaims.metadata.role` for the middleware check; use Convex for the layout-level defense check (already the pattern in admin layout.tsx).
- **Don't use Clerk's built-in subscription features**: These are Stripe-based. InstaPay/Vodafone Cash are manual — Clerk Billing won't help here.
- **Don't hand-roll invitation tokens**: JWT expiry, one-time use, HMAC verification — all error-prone. Clerk Invitations handle this.
- **Don't add `ClerkProvider` to the marketing app root**: The entire marketing app is public. Only the redirect page (`/accept-invite`) in the client app needs Clerk.
- **Don't forget the `@layer theme, base, clerk, components, utilities;` Tailwind v4 fix**: When adding `ClerkProvider` to the client app's locale layout, add `cssLayerName: 'clerk'` and the `@layer` declaration to `globals.css`. Currently the client app has `ClerkProvider` inside `ConvexClientProvider` but the `cssLayerName` appearance prop is missing — this should be added.
- **Don't forget `CLERK_SECRET_KEY` in Convex environment**: Convex actions run on Convex servers, not on Vercel. The `CLERK_SECRET_KEY` must be set in the Convex deployment environment variables (via `npx convex env set CLERK_SECRET_KEY ...`), NOT just in `.env.local`.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Invitation link generation | Custom JWT + email link | `clerkClient.invitations.createInvitation` | Token expiry, one-time use, HMAC signing, Clerk-branded email — all handled |
| Role-based access control | Middleware DB query | `sessionClaims?.metadata?.role` from Clerk JWT | Sub-millisecond JWT check vs 50-200ms DB round-trip |
| Payment screenshot file upload | S3/GCS presigned URLs | Convex `storage.generateUploadUrl` + HTTP action | Already in the stack, integrated with Convex storage |
| Rejection user cleanup | Manual profile deletion | `clerkClient.users.deleteUser` triggers Clerk webhook → Convex `deleteProfileFromClerk` | Cascading cleanup is already wired in `convex/http.ts` |
| Real-time approval status | Polling `setInterval` | Convex `useQuery` reactive subscriptions | Already the pattern; zero extra work |

**Key insight:** Clerk handles the entire token-based invitation lifecycle. Convex handles the profile lifecycle via webhooks. Neither needs custom plumbing.

---

## Common Pitfalls

### Pitfall 1: Convex Action vs Mutation for Clerk API Calls

**What goes wrong:** Clerk Backend API calls (`import "@clerk/backend"`) require Node.js runtime. Convex mutations run in the Convex V8 runtime (not Node.js). Calling `clerkClient` from a mutation will fail with a runtime error.

**Why it happens:** Convex `mutation` and `query` use a restricted V8 environment. Only `action` and `internalAction` with `"use node"` at the top of the file run in Node.js.

**How to avoid:** Any code calling `clerkClient` must be in a Convex `action` or `internalAction` in a file that starts with `"use node"`. The pattern for the approval flow: `approveSignup` becomes a mutation that patches Convex data, and then `ctx.scheduler.runAfter(0, internal.someFile.sendClerkInvitation, ...)` schedules the Clerk API call as an action.

**Warning signs:** `ReferenceError: require is not defined` or `Cannot find module 'node:crypto'` in Convex action logs.

### Pitfall 2: Clerk Invitation vs Clerk Magic Link

**What goes wrong:** Confusing Clerk "Email Links" (magic login links for existing users) with Clerk "Invitations" (one-time ticket for new user creation). The CONTEXT.md says "magic link email" — this is colloquial language for the invitation email, NOT the `useSignIn` magic link flow.

**Why it happens:** The client app already has a `/magic-link` page that uses `useSignIn.create({ strategy: "email_link" })`. This is for EXISTING users who forgot their password. The signup invitation uses `clerkClient.invitations.createInvitation` + the accept page uses `useSignUp.create({ strategy: "ticket", ticket: token })`.

**How to avoid:** The `/accept-invite` page uses `useSignUp` (not `useSignIn`). The `__clerk_ticket` query param is the invitation token. Never route invitation clicks through the existing magic-link page.

**Warning signs:** The `__clerk_ticket` param is present in the URL but the page uses `signIn` instead of `signUp` — this will fail because the user doesn't exist yet.

### Pitfall 3: Rejection Timing — Clerk User May Not Exist

**What goes wrong:** Coach rejects a signup before the prospect has accepted the invitation and created their Clerk account. Calling `clerkClient.users.deleteUser(userId)` fails because no user exists.

**Why it happens:** The flow has a gap between "Clerk invitation sent" and "Clerk user created". The prospect may ignore the email for days.

**How to avoid:** In `rejectSignup`, first call `clerkClient.users.getUserList({ emailAddress: [email] })`. If `users.data.length === 0`, skip the user deletion step. Still patch the signup record and send the rejection email. If the prospect eventually clicks the old invitation link, the invitation may already be accepted or the `__clerk_ticket` will fail gracefully.

**Warning signs:** 404 error from Clerk when deleting user during rejection.

### Pitfall 4: Marketing App Port Configuration in Turbo

**What goes wrong:** Adding a 3rd app to the monorepo without updating `turbo.json` or the root `package.json` scripts means `pnpm dev` doesn't start it.

**How to avoid:** Update root `package.json` to add:
```json
"dev:marketing": "turbo run dev --filter=@fitfast/marketing",
"dev": "turbo run dev --filter=@fitfast/client --filter=@fitfast/admin --filter=@fitfast/marketing"
```

Also update `pnpm-workspace.yaml` — it's already `"apps/*"` so the new app is automatically included.

### Pitfall 5: Tailwind v4 cssLayerName Missing in ClerkProvider

**What goes wrong:** Clerk's injected styles override Tailwind utility classes (e.g., Clerk modal background color bleeds into the page). This is a Tailwind v4 + Clerk conflict.

**How to avoid:** Add to the `ClerkProvider` in `apps/client/src/components/providers/convex-provider.tsx`:
```typescript
<ClerkProvider appearance={{ cssLayerName: 'clerk' }}>
```
And add to `apps/client/src/app/globals.css` at the very top:
```css
@layer theme, base, clerk, components, utilities;
@import "tailwindcss";
```

**Source:** Clerk Docs — Tailwind CSS v4 compatibility (HIGH confidence, verified Context7)

### Pitfall 6: `CLERK_SECRET_KEY` Not Available in Convex Actions

**What goes wrong:** Convex actions can access environment variables but only those set in the Convex deployment. The `.env.local` file is for Next.js apps, not Convex. `process.env.CLERK_SECRET_KEY` is undefined in Convex actions.

**How to avoid:** Set the secret key in Convex:
```bash
npx convex env set CLERK_SECRET_KEY sk_test_...
```
Also needed: `npx convex env set CLIENT_APP_URL https://client.fitfast.app` for the invitation `redirectUrl`.

---

## Code Examples

### Accept Invite Page (Client App)
```typescript
// Source: Clerk Docs — Application Invitations Custom Flow
// apps/client/src/app/[locale]/(auth)/accept-invite/page.tsx
"use client";
import { useSignUp, useUser } from "@clerk/nextjs";
import { useSearchParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";

export default function AcceptInvitePage() {
  const { signUp, setActive, isLoaded } = useSignUp();
  const { isSignedIn } = useUser();
  const router = useRouter();
  const [password, setPassword] = useState("");
  const token = useSearchParams().get("__clerk_ticket");

  useEffect(() => {
    if (isSignedIn) router.replace("/pending");
  }, [isSignedIn, router]);

  if (!token) return <p>Invalid invitation link.</p>;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!isLoaded || !signUp) return;
    const result = await signUp.create({ strategy: "ticket", ticket: token, password });
    if (result.status === "complete") {
      await setActive!({ session: result.createdSessionId });
      // router.replace handled by the isSignedIn useEffect above
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="password" value={password} onChange={e => setPassword(e.target.value)} />
      <div id="clerk-captcha" /> {/* Required for bot protection */}
      <button type="submit">Set Password & Join</button>
    </form>
  );
}
```

### Coach Role Check in Admin Middleware
```typescript
// Source: Clerk Docs — Basic RBAC
// apps/admin/src/middleware.ts
export default clerkMiddleware(async (auth, request: NextRequest) => {
  const path = stripLocale(request.nextUrl.pathname);
  if (path === "/login") return intlMiddleware(request);

  const { userId, sessionClaims } = await auth();
  const locale = getLocaleFromPath(request.nextUrl.pathname);

  if (!userId) {
    return NextResponse.redirect(new URL(`/${locale}/login`, request.nextUrl.origin));
  }

  // Role check via JWT — no DB query needed in middleware
  if ((sessionClaims as { metadata?: { role?: string } })?.metadata?.role !== "coach") {
    return NextResponse.redirect(
      new URL(`/${locale}/login?error=not_coach`, request.nextUrl.origin)
    );
  }

  return intlMiddleware(request);
});
```

### Convex approveSignup Action (triggers Clerk Invitation)
```typescript
// Source: Clerk Docs — createInvitation; Convex Docs — actions
// convex/pendingSignups.ts
export const approveSignup = mutation({
  args: { signupId: v.id("pendingSignups") },
  handler: async (ctx, { signupId }) => {
    // ... auth check ...
    await ctx.db.patch(signupId, { status: "approved", reviewedAt: Date.now() });
    const signup = await ctx.db.get(signupId);
    if (signup?.email) {
      // Schedule Clerk invitation as a separate action (requires Node.js runtime)
      await ctx.scheduler.runAfter(0, internal.clerkActions.sendInvitation, {
        email: signup.email,
        fullName: signup.fullName,
        signupId,
      });
    }
  },
});
```

```typescript
// convex/clerkActions.ts (new file — "use node" at top)
"use node";
import { internalAction } from "./_generated/server";
import { v } from "convex/values";

export const sendInvitation = internalAction({
  args: { email: v.string(), fullName: v.string(), signupId: v.id("pendingSignups") },
  handler: async (_ctx, { email, fullName, signupId }): Promise<void> => {
    const { createClerkClient } = await import("@clerk/backend");
    const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET_KEY! });
    await clerkClient.invitations.createInvitation({
      emailAddress: email,
      redirectUrl: `${process.env.CLIENT_APP_URL}/en/accept-invite`,
      publicMetadata: { signupId, fullName },
      notify: true,
    });
  },
});
```

### Pending Page — Real-Time Auto-Redirect (No Polling)
```typescript
// Updated pending page — key change: remove manual "Check Status" button
useEffect(() => {
  if (profile === null) return; // Not loaded
  if (profile?.status === "active") {
    router.replace("/initial-assessment");
  }
  // On rejection (account deleted), profile becomes null → redirect to login
}, [profile?.status, router]);
```

---

## State of the Art

| Old Approach | Current Approach | Impact |
|--------------|------------------|--------|
| Admin checks `isCoach` from Convex in layout | JWT `sessionClaims.metadata.role` in middleware | No DB query on every admin page load for auth gate |
| Custom email link tokens | Clerk Invitations API | One-time use, expiry, branding all handled |
| `approveSignup` only sends welcome email (existing) | `approveSignup` also sends Clerk invitation | Closes the loop: approval → account creation |

**Existing code that needs updating (not deleting):**

- `convex/pendingSignups.ts` `approveSignup`: Currently sends `sendWelcomeEmail` action. Must be updated to instead send Clerk invitation (the welcome email becomes the Clerk invitation email). After the prospect accepts and sets their password, the Convex webhook creates their profile. On coach approval of the profile, the existing welcome email (telling them they're approved) still makes sense.

- `convex/pendingSignups.ts` `rejectSignup`: Currently just patches status. Must be upgraded to an action that also deletes the Clerk user and sends a rejection email with reason.

- `apps/client/src/app/[locale]/(onboarding)/pending/page.tsx`: Remove the "Check Status" button. The Convex real-time subscription already works; the button was a UX crutch. Update stepper steps to match new flow (no assessment step in stepper).

- `apps/admin/src/app/[locale]/(panel)/signups/signups-table.tsx`: Add rejection reason input. Add link to detail view. Fix payment screenshot display (call `api.storage.getFileUrl`).

---

## Open Questions

1. **Clerk invitation email template**
   - What we know: Clerk sends a default "You've been invited" email. You can customize it in Clerk Dashboard → Email Templates.
   - What's unclear: Whether we can fully replace the email text to say "Welcome to FitFast — click to set up your account" without it looking like a generic Clerk invite.
   - Recommendation: Customize Clerk's invitation email template in the dashboard. The template supports variables for `{{app_name}}`, `{{invitation_url}}`. This avoids building a custom email step.

2. **acceptInvitation flow: what URL does Clerk send?**
   - What we know: The `redirectUrl` in `createInvitation` determines where the user lands. The `__clerk_ticket` is appended as a query param.
   - What's unclear: Whether Clerk first sends the user to `accounts.clerk.com` (hosted auth) and then redirects, or directly to the `redirectUrl`.
   - Recommendation: Test during implementation. If using the custom `/accept-invite` page in the client app, configure Clerk Dashboard → Paths to have the "Invitation accept URL" pointing to the client domain. This is a one-line Clerk dashboard setting.

3. **`rejectSignup` — what if invitation was never accepted?**
   - What we know: `clerkClient.users.getUserList({ emailAddress: [email] })` returns empty if no user exists.
   - What's unclear: Whether the pending invitation itself should also be revoked (to prevent the prospect from later accepting it).
   - Recommendation: On rejection, also call `clerkClient.invitations.revokeInvitation(invitationId)`. To do this, store the Clerk `invitationId` in the `pendingSignups` record when sending the invitation.

4. **Marketing app domain in production**
   - What we know: Three Vercel deployments needed: `client.fitfast.app`, `admin.fitfast.app`, `fitfast.app` (or `www.fitfast.app` for marketing).
   - Recommendation: Store `CLIENT_APP_URL` as an env variable so the Clerk invitation `redirectUrl` is correct across environments (dev uses `http://localhost:3000`).

---

## Sources

### Primary (HIGH confidence)
- `/clerk/clerk-docs` (Context7) — Invitations API, publicMetadata roles, RBAC middleware pattern, deleteUser, updateUserMetadata, Tailwind v4 cssLayerName
- `/clerk/clerk-nextjs-app-quickstart` (Context7) — ClerkProvider setup, middleware route matching
- Codebase: `convex/pendingSignups.ts`, `convex/email.ts`, `convex/http.ts`, `convex/profiles.ts`, `convex/schema.ts`
- Codebase: `apps/client/src/components/providers/convex-provider.tsx`
- Codebase: `apps/admin/src/app/[locale]/(panel)/layout.tsx`, `apps/admin/src/app/[locale]/login/page.tsx`
- Codebase: `apps/client/src/middleware.ts`, `apps/admin/src/middleware.ts`
- Codebase: `apps/client/src/app/globals.css` (design tokens), `apps/client/src/app/layout.tsx`
- Codebase: `apps/client/src/app/[locale]/(onboarding)/pending/page.tsx`
- Codebase: `apps/admin/src/app/[locale]/(panel)/signups/signups-table.tsx`
- Codebase: `packages/i18n/src/routing.ts`, `packages/ui/package.json`

### Secondary (MEDIUM confidence)
- Turbo dev scripts pattern: verified by reading existing `turbo.json` and `pnpm-workspace.yaml`
- Convex HTTP action for unauthenticated upload URL: pattern extrapolated from existing `convex/http.ts` structure

### Tertiary (LOW confidence)
- Clerk invitation email template customization capability — documented in Clerk Dashboard but not tested in this project

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — all libraries already in the codebase, Clerk API verified via Context7
- Architecture: HIGH — patterns derive directly from existing codebase structure + Clerk docs
- Pitfalls: HIGH — Convex Node.js runtime requirement and Clerk JWT vs DB query patterns are well-documented gotchas

**Research date:** 2026-02-20
**Valid until:** 2026-03-20 (Clerk APIs stable; Convex stable)
