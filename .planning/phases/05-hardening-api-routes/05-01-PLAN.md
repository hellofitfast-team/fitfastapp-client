---
phase: 05-hardening-api-routes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api-validation/index.ts
  - src/lib/api-validation/plans.ts
  - src/lib/api-validation/tickets.ts
  - src/lib/api-validation/admin.ts
  - src/lib/api-validation/notifications.ts
  - src/lib/api-validation/auth.ts
autonomous: true

must_haves:
  truths:
    - "validateRequestBody helper returns typed success or 400 NextResponse"
    - "All API input schemas exist and match database column constraints"
    - "Validation failures are logged to Sentry with userId and feature tag"
  artifacts:
    - path: "src/lib/api-validation/index.ts"
      provides: "validateRequestBody helper + barrel exports"
      exports: ["validateRequestBody"]
    - path: "src/lib/api-validation/plans.ts"
      provides: "GeneratePlanSchema for meal/workout plan generation"
      exports: ["GeneratePlanSchema"]
    - path: "src/lib/api-validation/tickets.ts"
      provides: "CreateTicketSchema for ticket creation"
      exports: ["CreateTicketSchema"]
    - path: "src/lib/api-validation/admin.ts"
      provides: "OcrRequestSchema, OcrResultSchema, ApproveSignupSchema, SendNotificationSchema"
      exports: ["OcrRequestSchema", "OcrResultSchema", "ApproveSignupSchema", "SendNotificationSchema"]
    - path: "src/lib/api-validation/notifications.ts"
      provides: "SubscriptionSchema, UnsubscribeSchema, ReminderTimeSchema"
      exports: ["SubscriptionSchema", "UnsubscribeSchema", "ReminderTimeSchema"]
    - path: "src/lib/api-validation/auth.ts"
      provides: "SignInSchema for magic link sign-in"
      exports: ["SignInSchema"]
  key_links:
    - from: "src/lib/api-validation/index.ts"
      to: "@sentry/nextjs"
      via: "Sentry.captureException on validation failure"
      pattern: "Sentry\\.captureException"
---

<objective>
Create the API validation infrastructure: a reusable validateRequestBody() helper and Zod schemas for all 13 API route endpoints.

Purpose: Foundation for Plans 02-04 which will apply these schemas to actual routes. Centralizing schemas in lib/api-validation/ ensures consistency and reusability.
Output: src/lib/api-validation/ directory with helper + 5 schema files
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-hardening-api-routes/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validateRequestBody helper</name>
  <files>src/lib/api-validation/index.ts</files>
  <action>
Create src/lib/api-validation/index.ts with:

1. A `validateRequestBody<T extends z.ZodTypeAny>(body: unknown, schema: T, context: { userId?: string; feature: string })` function that:
   - Calls `schema.safeParse(body)`
   - On failure: logs to Sentry with `level: "warning"`, tags `{ feature: context.feature, validation: "request-body" }`, extra `{ userId, errors: result.error.issues, body }`
   - On failure: returns `{ success: false, response: NextResponse.json({ error: "Invalid request", details: result.error.issues.map(e => ({ field: e.path.join("."), message: e.message })) }, { status: 400 }) }`
   - On success: returns `{ success: true, data: z.infer<T> }`
   - Return type is a discriminated union: `{ success: true; data: z.infer<T> } | { success: false; response: NextResponse }`

2. Barrel exports for all schema files (plans, tickets, admin, notifications, auth).

Import Sentry from `@sentry/nextjs`, NextResponse from `next/server`, z from `zod`.
  </action>
  <verify>TypeScript compiles: `pnpm tsc --noEmit 2>&1 | grep -c "error TS"` returns 0 new errors</verify>
  <done>validateRequestBody function exists, exports are resolvable, Sentry integration present</done>
</task>

<task type="auto">
  <name>Task 2: Create all Zod validation schemas</name>
  <files>
    src/lib/api-validation/plans.ts
    src/lib/api-validation/tickets.ts
    src/lib/api-validation/admin.ts
    src/lib/api-validation/notifications.ts
    src/lib/api-validation/auth.ts
  </files>
  <action>
Create 5 schema files. Each schema should match the existing route's expected body shape and database column constraints.

**plans.ts:**
```typescript
export const GeneratePlanSchema = z.object({
  checkInId: z.string().uuid().optional(),
  planDuration: z.coerce.number().int().min(7).max(30).default(14),
});
```

**tickets.ts:**
```typescript
export const CreateTicketSchema = z.object({
  subject: z.string().min(1, "Subject is required").max(200),
  category: z.enum(["plan", "payment", "technical", "bug_report"]),
  description: z.string().max(2000).optional(),
  screenshot_url: z.string().url().optional().nullable(),
});
```

**admin.ts:**
```typescript
// OCR request input validation
export const OcrRequestSchema = z.object({
  imageBase64: z.string().optional(),
  imageUrl: z.string().url().optional(),
  signupId: z.string().uuid().optional(),
}).refine(
  data => data.imageBase64 || data.imageUrl,
  { message: "Provide imageBase64 or imageUrl" }
);

// OCR result validation (ADMIN-02) - validates AI output before DB save
export const OcrResultSchema = z.object({
  amount: z.string().regex(/^\d+(\.\d{1,2})?$/, "Amount must be a valid number").optional(),
  sender_name: z.string().min(1).max(100).optional(),
  reference_number: z.string().min(1).max(50).optional(),
  date: z.string().optional(),
  bank: z.string().min(1).max(50).optional(),
}).refine(
  data => Object.values(data).some(v => v !== undefined),
  { message: "At least one field must be extracted" }
);

export const ApproveSignupSchema = z.object({
  signupId: z.string().uuid("Invalid signup ID"),
});

export const SendNotificationSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
  message: z.string().min(1, "Message is required").max(1000),
  user_ids: z.array(z.string().uuid()).optional(),
  send_to_all: z.boolean().optional().default(false),
}).refine(
  data => data.send_to_all || (data.user_ids && data.user_ids.length > 0),
  { message: "Either send_to_all must be true or user_ids must be provided" }
);
```

**notifications.ts:**
```typescript
export const SubscriptionSchema = z.object({
  onesignal_subscription_id: z.string().min(1, "Subscription ID is required"),
  device_type: z.string().optional().default("web"),
});

export const UnsubscribeSchema = z.object({
  onesignal_subscription_id: z.string().min(1, "Subscription ID is required"),
});

export const ReminderTimeSchema = z.object({
  reminder_time: z.string().regex(/^\d{2}:\d{2}$/, "Invalid time format. Use HH:MM"),
});
```

**auth.ts:**
```typescript
export const SignInSchema = z.object({
  email: z.string().email("Invalid email address"),
  locale: z.enum(["en", "ar"]).optional().default("en"),
});
```

Each file imports `z` from `zod` and exports the schemas. Inferred types should also be exported where useful (e.g., `export type GeneratePlanInput = z.infer<typeof GeneratePlanSchema>`).
  </action>
  <verify>TypeScript compiles: `pnpm tsc --noEmit 2>&1 | grep -c "error TS"` returns 0 new errors. All schemas importable from `@/lib/api-validation`.</verify>
  <done>All 10 schemas exist with proper types, constraints match database columns, barrel exports work</done>
</task>

</tasks>

<verification>
- `pnpm tsc --noEmit` passes (no new errors)
- All files exist in src/lib/api-validation/
- `validateRequestBody` function importable from `@/lib/api-validation`
- All schemas importable from `@/lib/api-validation`
</verification>

<success_criteria>
- src/lib/api-validation/ directory exists with index.ts + 5 schema files
- validateRequestBody helper handles success and failure cases with Sentry logging
- All schemas match the existing route body expectations
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-hardening-api-routes/05-01-SUMMARY.md`
</output>
