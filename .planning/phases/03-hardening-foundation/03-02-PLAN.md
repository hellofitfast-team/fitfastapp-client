---
phase: 03-hardening-foundation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/validation/meal-plan.ts
  - src/lib/validation/workout-plan.ts
  - src/lib/validation/index.ts
  - src/components/errors/ErrorBoundary.tsx
autonomous: true

must_haves:
  truths:
    - "MealPlanSchema matches the GeneratedMealPlan interface structure exactly (weeklyPlan with day records, meals array, dailyTotals, weeklyTotals, notes)"
    - "WorkoutPlanSchema matches the GeneratedWorkoutPlan interface structure exactly (weeklyPlan with day records containing warmup/exercises/cooldown, progressionNotes, safetyTips)"
    - "validateMealPlan and validateWorkoutPlan use safeParse (never .parse()) and throw ValidationError from @/lib/errors on failure"
    - "cleanAIResponse strips markdown code block wrappers (```json and ```) before validation"
    - "ErrorBoundary component catches rendering errors, reports to Sentry with componentStack, and renders a customizable fallback UI"
    - "All schemas infer TypeScript types that are drop-in replacements for the existing GeneratedMealPlan and GeneratedWorkoutPlan interfaces"
  artifacts:
    - path: "src/lib/validation/meal-plan.ts"
      provides: "MealPlanSchema, MealSchema, DailyMealPlanSchema, validateMealPlan, cleanAIResponse"
      contains: "safeParse"
    - path: "src/lib/validation/workout-plan.ts"
      provides: "WorkoutPlanSchema, WorkoutExerciseSchema, validateWorkoutPlan"
      contains: "safeParse"
    - path: "src/lib/validation/index.ts"
      provides: "Barrel re-exports for all validation schemas and helpers"
    - path: "src/components/errors/ErrorBoundary.tsx"
      provides: "Reusable ErrorBoundary class component with Sentry integration"
      contains: "use client"
  key_links:
    - from: "src/lib/validation/meal-plan.ts"
      to: "src/lib/errors/types.ts"
      via: "import ValidationError"
      pattern: "import.*ValidationError.*from.*@/lib/errors"
    - from: "src/lib/validation/workout-plan.ts"
      to: "src/lib/errors/types.ts"
      via: "import ValidationError"
      pattern: "import.*ValidationError.*from.*@/lib/errors"
    - from: "src/components/errors/ErrorBoundary.tsx"
      to: "@sentry/nextjs"
      via: "captureException in componentDidCatch"
      pattern: "Sentry\\.captureException"
---

<objective>
Create Zod validation schemas for AI-generated plans and a reusable ErrorBoundary component.

Purpose: The validation schemas will be used by Phase 4 to validate meal/workout plan AI responses before database save (RELY-04). The ErrorBoundary component will be used by Phase 8 for route segment isolation. Building schemas that exactly match the existing GeneratedMealPlan/GeneratedWorkoutPlan interfaces ensures drop-in adoption without refactoring.

Output: `src/lib/validation/` directory with plan schemas and validate helpers, plus `src/components/errors/ErrorBoundary.tsx`.
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hardening-foundation/03-RESEARCH.md
@.planning/phases/03-hardening-foundation/03-01-SUMMARY.md
@src/lib/ai/meal-plan-generator.ts
@src/lib/ai/workout-plan-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas and validate helpers for meal and workout plans</name>
  <files>src/lib/validation/meal-plan.ts, src/lib/validation/workout-plan.ts, src/lib/validation/index.ts</files>
  <action>
**CRITICAL: Schemas must match the existing TypeScript interfaces exactly.** Read `src/lib/ai/meal-plan-generator.ts` (GeneratedMealPlan interface) and `src/lib/ai/workout-plan-generator.ts` (GeneratedWorkoutPlan interface) to get the exact field names and types.

1. Create `src/lib/validation/meal-plan.ts`:

   First, a shared helper at the top of the file:
   ```typescript
   /**
    * Strip markdown code block wrappers from AI responses.
    * OpenRouter models sometimes return ```json ... ``` despite "no markdown" in prompt.
    */
   export function cleanAIResponse(raw: string): string {
     return raw.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
   }
   ```

   Then define schemas matching GeneratedMealPlan exactly:

   - **MealSchema**: z.object with fields: name (string min 1), type (enum: "breakfast", "lunch", "dinner", "snack"), time (string — use .min(1) not regex, AI may use varied time formats), calories (number positive), protein (number nonnegative), carbs (number nonnegative), fat (number nonnegative), ingredients (array of string min 1, array min 1), instructions (array of string min 1, array min 1), alternatives (array of string, optional — use `.optional()` since the interface has `?`).

   - **DailyMealPlanSchema**: z.object with: meals (array of MealSchema, min 1), dailyTotals (z.object with calories positive, protein nonneg, carbs nonneg, fat nonneg).

   - **MealPlanSchema**: z.object with: weeklyPlan (z.record of string to DailyMealPlanSchema), weeklyTotals (z.object with calories positive, protein nonneg, carbs nonneg, fat nonneg), notes (string).

   Export inferred types: `type ValidatedMealPlan = z.infer<typeof MealPlanSchema>` (etc.)

   Then the validate helper:
   ```typescript
   import { ValidationError } from "@/lib/errors";
   import * as Sentry from "@sentry/nextjs";

   /**
    * Validate an AI-generated meal plan response.
    * Cleans markdown wrappers, parses JSON, validates with Zod schema.
    *
    * @param rawResponse - Raw string response from OpenRouter API
    * @returns Validated and typed MealPlan object
    * @throws ValidationError if JSON parsing or schema validation fails
    */
   export function validateMealPlanResponse(rawResponse: string): ValidatedMealPlan {
     let parsed: unknown;
     try {
       parsed = JSON.parse(cleanAIResponse(rawResponse));
     } catch (error) {
       Sentry.captureException(error, {
         tags: { feature: "meal-plan-validation", stage: "json-parse" },
         extra: { rawResponse: rawResponse.substring(0, 500) },
       });
       throw new ValidationError(
         "Failed to parse meal plan JSON from AI response",
       );
     }

     const result = MealPlanSchema.safeParse(parsed);
     if (!result.success) {
       Sentry.captureException(
         new ValidationError("Meal plan schema validation failed", result.error),
         {
           tags: { feature: "meal-plan-validation", stage: "schema" },
           extra: {
             errorCount: result.error.issues.length,
             issues: result.error.issues.slice(0, 5),
           },
         }
       );
       throw new ValidationError(
         `Invalid meal plan structure: ${result.error.issues.map(e => e.message).join(", ")}`,
         result.error
       );
     }

     return result.data;
   }
   ```

2. Create `src/lib/validation/workout-plan.ts`:

   Define schemas matching GeneratedWorkoutPlan exactly:

   - **WarmupExerciseSchema**: z.object with name (string min 1), duration (number positive, in seconds), instructions (array of string min 1, min 1 item).

   - **WorkoutExerciseSchema**: z.object with name (string min 1), sets (number positive int), reps (string min 1 — can be "10-12" or "30 seconds"), rest (number nonnegative, seconds), notes (string optional), targetMuscles (array of string min 1, min 1 item), equipment (string optional).

   - **CooldownExerciseSchema**: Same shape as WarmupExerciseSchema (reuse or define separately — same fields: name, duration, instructions).

   - **DailyWorkoutSchema**: z.object with workoutName (string min 1), duration (number positive, minutes), targetMuscles (array of string), warmup (z.object with exercises array of WarmupExerciseSchema), exercises (array of WorkoutExerciseSchema), cooldown (z.object with exercises array of CooldownExerciseSchema), restDay (boolean optional).

   - **WorkoutPlanSchema**: z.object with weeklyPlan (z.record of string to DailyWorkoutSchema), progressionNotes (string), safetyTips (array of string min 1).

   Export inferred types.

   Then the validate helper (same pattern as meal-plan):
   ```typescript
   import { cleanAIResponse } from "./meal-plan";
   import { ValidationError } from "@/lib/errors";
   import * as Sentry from "@sentry/nextjs";

   export function validateWorkoutPlanResponse(rawResponse: string): ValidatedWorkoutPlan {
     // Same pattern: cleanAIResponse -> JSON.parse -> safeParse -> throw ValidationError
     // Use tags: { feature: "workout-plan-validation" }
   }
   ```

3. Create `src/lib/validation/index.ts` as barrel file:
   - Re-export everything from "./meal-plan": schemas, types, validateMealPlanResponse, cleanAIResponse
   - Re-export everything from "./workout-plan": schemas, types, validateWorkoutPlanResponse
   - This lets consumers do `import { validateMealPlanResponse, MealPlanSchema } from "@/lib/validation";`

**IMPORTANT:** Use `.safeParse()` everywhere (NEVER `.parse()`). The validate helpers throw ValidationError from `@/lib/errors` (created in Plan 01). Zod is already installed (v4.3.6) — do NOT install it again.
  </action>
  <verify>
Run `pnpm tsc --noEmit` to confirm no TypeScript errors. Verify that the inferred types from MealPlanSchema match the GeneratedMealPlan interface fields. Verify that validateMealPlanResponse and validateWorkoutPlanResponse use safeParse (grep for ".parse(" to ensure no unsafe parse calls).
  </verify>
  <done>Zod schemas exist for meal plans and workout plans matching the existing GeneratedMealPlan/GeneratedWorkoutPlan interfaces. Validate helpers clean AI responses, parse JSON safely, validate with Zod, and throw ValidationError on failure with Sentry context.</done>
</task>

<task type="auto">
  <name>Task 2: Create reusable ErrorBoundary component</name>
  <files>src/components/errors/ErrorBoundary.tsx</files>
  <action>
Create `src/components/errors/ErrorBoundary.tsx` as a "use client" React class component:

```typescript
"use client";

import { Component, type ReactNode, type ErrorInfo } from "react";
import * as Sentry from "@sentry/nextjs";
```

**Props interface (ErrorBoundaryProps):**
- `children: ReactNode` (required)
- `fallback?: (error: Error, reset: () => void) => ReactNode` (optional custom fallback renderer)
- `onError?: (error: Error, errorInfo: ErrorInfo) => void` (optional custom error handler)

**State interface (ErrorBoundaryState):**
- `hasError: boolean`
- `error: Error | null`

**Class implementation:**
- Constructor: Initialize state `{ hasError: false, error: null }`
- `static getDerivedStateFromError(error: Error)`: Return `{ hasError: true, error }`
- `componentDidCatch(error: Error, errorInfo: ErrorInfo)`:
  1. Capture to Sentry: `Sentry.captureException(error, { contexts: { react: { componentStack: errorInfo.componentStack } } })`
  2. Call `this.props.onError?.(error, errorInfo)`
- `reset` method (arrow function for stable reference): Set state back to `{ hasError: false, error: null }`
- `render()`:
  - If `hasError && error`:
    - If `fallback` prop provided: return `this.props.fallback(this.state.error, this.reset)`
    - Otherwise render default fallback UI: A styled div with rounded border, error-themed colors using Tailwind classes (border-red-200, bg-red-50, text-red-900, etc. — use standard Tailwind reds, not semantic error classes that may not exist). Show error heading "Something went wrong", error message text, and a "Try again" button that calls `this.reset()`.
  - Otherwise: return `this.props.children`

**Use standard Tailwind red colors** (red-50, red-200, red-600, red-700, red-900) for the default fallback, NOT semantic error-* classes. The semantic classes may not be defined in the project's Tailwind config.

Add JSDoc to the class explaining usage with custom fallback and the reset mechanism. Export as named export.
  </action>
  <verify>
Run `pnpm tsc --noEmit` to confirm no TypeScript errors. Verify the file has "use client" directive at the top. Verify it imports and calls Sentry.captureException in componentDidCatch.
  </verify>
  <done>ErrorBoundary component catches rendering errors, reports to Sentry with component stack, and renders either a custom fallback or a styled default error UI with a reset button.</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero errors
2. All files exist: src/lib/validation/meal-plan.ts, src/lib/validation/workout-plan.ts, src/lib/validation/index.ts, src/components/errors/ErrorBoundary.tsx
3. MealPlanSchema field structure matches GeneratedMealPlan interface in meal-plan-generator.ts
4. WorkoutPlanSchema field structure matches GeneratedWorkoutPlan interface in workout-plan-generator.ts
5. No `.parse()` calls — only `.safeParse()` used for untrusted data
6. validateMealPlanResponse and validateWorkoutPlanResponse both call cleanAIResponse before JSON.parse
7. Both validate helpers throw ValidationError (imported from @/lib/errors)
8. ErrorBoundary.tsx has "use client" directive and calls Sentry.captureException
9. Barrel file (index.ts) re-exports all schemas, types, and validate helpers
</verification>

<success_criteria>
- Zod schemas match existing TypeScript interfaces (drop-in replacement for Phase 4)
- Validate helpers handle full pipeline: clean markdown -> parse JSON -> validate schema -> throw with context
- ErrorBoundary component works as standalone wrapper with Sentry integration
- All utilities have JSDoc comments
- Clean barrel imports from "@/lib/validation"
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-hardening-foundation/03-02-SUMMARY.md`
</output>
