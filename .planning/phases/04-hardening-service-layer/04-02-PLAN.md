---
phase: 04-hardening-service-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/queries/profiles.ts
  - src/lib/supabase/queries/assessments.ts
  - src/lib/supabase/queries/check-ins.ts
  - src/lib/supabase/queries/plans.ts
  - src/lib/supabase/queries/index.ts
  - src/app/api/plans/meal/route.ts
  - src/app/api/plans/workout/route.ts
autonomous: true

must_haves:
  truths:
    - "Profile lookup by userId is a single reusable function (not duplicated across routes)"
    - "Assessment lookup by userId is a single reusable function (not duplicated across routes)"
    - "Check-in lookup by id is a single reusable function"
    - "All extracted query functions log errors to Sentry with context (userId, feature tag, error code)"
    - "All extracted query functions throw AppError with descriptive code (PROFILE_NOT_FOUND, etc.)"
    - "Meal plan API route uses extracted queries instead of inline .from().select()"
    - "Workout plan API route uses extracted queries instead of inline .from().select()"
    - "API route catch blocks log to Sentry with userId, action, timestamp context"
  artifacts:
    - path: "src/lib/supabase/queries/profiles.ts"
      provides: "getProfileById query function"
      exports: ["getProfileById"]
    - path: "src/lib/supabase/queries/assessments.ts"
      provides: "getAssessmentByUserId query function"
      exports: ["getAssessmentByUserId"]
    - path: "src/lib/supabase/queries/check-ins.ts"
      provides: "getCheckInById query function"
      exports: ["getCheckInById"]
    - path: "src/lib/supabase/queries/plans.ts"
      provides: "saveMealPlan, saveWorkoutPlan query functions"
      exports: ["saveMealPlan", "saveWorkoutPlan"]
    - path: "src/lib/supabase/queries/index.ts"
      provides: "Barrel exports for all query functions"
    - path: "src/app/api/plans/meal/route.ts"
      provides: "Hardened meal plan API using extracted queries and Sentry"
      contains: "getProfileById"
    - path: "src/app/api/plans/workout/route.ts"
      provides: "Hardened workout plan API using extracted queries and Sentry"
      contains: "getProfileById"
  key_links:
    - from: "src/lib/supabase/queries/profiles.ts"
      to: "@/lib/errors"
      via: "import AppError for typed errors"
      pattern: "import.*AppError.*from.*@/lib/errors"
    - from: "src/app/api/plans/meal/route.ts"
      to: "@/lib/supabase/queries"
      via: "import query functions"
      pattern: "import.*getProfileById.*from.*@/lib/supabase/queries"
    - from: "src/app/api/plans/workout/route.ts"
      to: "@/lib/supabase/queries"
      via: "import query functions"
      pattern: "import.*getProfileById.*from.*@/lib/supabase/queries"
---

<objective>
Extract duplicated Supabase queries into reusable typed functions in lib/supabase/queries/, then update the meal and workout plan API routes to use them with Sentry error context.

Purpose: The meal and workout plan routes have identical profile/assessment/check-in fetch patterns (copy-pasted). Extracting to query functions eliminates duplication, adds consistent error handling with Sentry, and gives Phase 5 (API Routes) a reusable query layer to build on.

Output: Five new query files in src/lib/supabase/queries/ with typed functions, and two updated API routes that consume them with proper Sentry error context.
</objective>

<execution_context>
@/Users/ziadadel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ziadadel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hardening-service-layer/04-RESEARCH.md
@src/app/api/plans/meal/route.ts
@src/app/api/plans/workout/route.ts
@src/lib/supabase/server.ts
@src/types/database.ts
@src/lib/errors/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extracted Supabase query functions</name>
  <files>
    src/lib/supabase/queries/profiles.ts
    src/lib/supabase/queries/assessments.ts
    src/lib/supabase/queries/check-ins.ts
    src/lib/supabase/queries/plans.ts
    src/lib/supabase/queries/index.ts
  </files>
  <action>
  Create the src/lib/supabase/queries/ directory and five files:

  **1. profiles.ts** - Profile queries:
  ```typescript
  import type { SupabaseClient } from "@supabase/supabase-js";
  import type { Database, Profile } from "@/types/database";
  import { AppError } from "@/lib/errors";
  import * as Sentry from "@sentry/nextjs";

  export async function getProfileById(
    supabase: SupabaseClient<Database>,
    userId: string
  ): Promise<Profile> {
    const { data, error } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", userId)
      .single<Profile>();

    if (error || !data) {
      Sentry.captureException(error || new Error("Profile not found"), {
        tags: { feature: "profile-query" },
        extra: { userId, errorCode: error?.code },
      });
      throw new AppError("Profile not found", "PROFILE_NOT_FOUND", { userId });
    }

    return data;
  }
  ```

  **2. assessments.ts** - Assessment queries:
  Same pattern — `getAssessmentByUserId(supabase, userId)` returns `InitialAssessment`.
  Query: `.from("initial_assessments").select("*").eq("user_id", userId).single<InitialAssessment>()`.
  Error: `AppError("Assessment not found", "ASSESSMENT_NOT_FOUND", { userId })`.
  Sentry tag: `feature: "assessment-query"`.

  **3. check-ins.ts** - Check-in queries:
  `getCheckInById(supabase, checkInId)` returns `CheckIn | null`.
  This one returns null instead of throwing because check-in is optional in plan generation.
  Query: `.from("check_ins").select("*").eq("id", checkInId).single<CheckIn>()`.
  If error, log to Sentry with `feature: "check-in-query"` but return null (non-critical).

  **4. plans.ts** - Plan save functions:
  Two functions:

  `saveMealPlan(supabase, params: { userId, checkInId?, planData, language, startDate, endDate })` returns saved row.
  Uses `.insert({...} as never).select().single()` pattern (per Supabase type workaround in MEMORY.md).
  Throws `AppError("Failed to save meal plan", "MEAL_PLAN_SAVE_FAILED", { userId })` on error.
  Sentry tag: `feature: "meal-plan-save"`.

  `saveWorkoutPlan(supabase, params: { userId, checkInId?, planData, language, startDate, endDate })` — same pattern for workout_plans table.
  Error code: `WORKOUT_PLAN_SAVE_FAILED`.
  Sentry tag: `feature: "workout-plan-save"`.

  IMPORTANT type workaround: Use `as never` cast on insert payloads per project MEMORY.md. Use `.single<MealPlan>()` / `.single<WorkoutPlan>()` on the return.

  **5. index.ts** - Barrel exports:
  ```typescript
  export { getProfileById } from "./profiles";
  export { getAssessmentByUserId } from "./assessments";
  export { getCheckInById } from "./check-ins";
  export { saveMealPlan, saveWorkoutPlan } from "./plans";
  ```
  </action>
  <verify>
  Run `pnpm tsc --noEmit 2>&1 | head -30` — zero errors from src/lib/supabase/queries/.
  Verify all 5 files exist: profiles.ts, assessments.ts, check-ins.ts, plans.ts, index.ts.
  Grep for `AppError` in the queries directory to confirm proper error types.
  Grep for `Sentry.captureException` in the queries directory to confirm logging.
  Grep for `as never` in plans.ts to confirm Supabase type workaround is applied.
  </verify>
  <done>
  Five query files exist with typed functions, each logging errors to Sentry with feature tags and userId context, throwing AppError with descriptive codes, and using proper Supabase type workarounds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update plan API routes to use extracted queries and Sentry context</name>
  <files>
    src/app/api/plans/meal/route.ts
    src/app/api/plans/workout/route.ts
  </files>
  <action>
  Update both plan generation API routes to use extracted query functions and add Sentry error context:

  **For src/app/api/plans/meal/route.ts:**

  1. Add imports:
     ```typescript
     import { getProfileById } from "@/lib/supabase/queries/profiles";
     import { getAssessmentByUserId } from "@/lib/supabase/queries/assessments";
     import { getCheckInById } from "@/lib/supabase/queries/check-ins";
     import { saveMealPlan } from "@/lib/supabase/queries/plans";
     import * as Sentry from "@sentry/nextjs";
     ```

  2. Replace inline profile fetch:
     ```typescript
     // OLD: const { data: profile, error: profileError } = await supabase.from("profiles")...
     // NEW:
     const profile = await getProfileById(supabase, user.id);
     ```

  3. Replace inline assessment fetch:
     ```typescript
     // OLD: const { data: assessment, error: assessmentError } = await supabase.from("initial_assessments")...
     // NEW:
     const assessment = await getAssessmentByUserId(supabase, user.id);
     ```

  4. Replace inline check-in fetch:
     ```typescript
     // OLD: let checkIn: any = null; if (checkInId) { const { data: checkInData } = ...
     // NEW:
     const checkIn = checkInId ? await getCheckInById(supabase, checkInId) : null;
     ```

  5. Remove the `as any` type assertions for typedProfile and typedAssessment — the query functions already return properly typed Profile and InitialAssessment. Pass them directly to generateMealPlan(). Cast to `any` only at the generateMealPlan call if TypeScript complains about the Profile/InitialAssessment types not matching the generator's imports.

  6. Replace inline plan save with saveMealPlan():
     ```typescript
     const savedPlan = await saveMealPlan(supabase, {
       userId: user.id,
       checkInId: checkInId || null,
       planData: generatedPlan,
       language: profile.language,
       startDate: startDate.toISOString().split("T")[0],
       endDate: endDate.toISOString().split("T")[0],
     });
     ```
     Remove the old `saveError` handling since saveMealPlan throws on failure.

  7. Replace the outer catch block — replace `console.error` with Sentry:
     ```typescript
     catch (error) {
       Sentry.captureException(error, {
         tags: { feature: "meal-plan-generation" },
         extra: {
           userId: user?.id,
           action: "generate-meal-plan",
           timestamp: new Date().toISOString(),
         },
       });
       return NextResponse.json(
         { error: "Failed to generate meal plan" },
         { status: 500 }
       );
     }
     ```

  8. Keep the fire-and-forget OneSignal notification block, but add Sentry logging to the catch:
     ```typescript
     try {
       getOneSignalClient().sendToUser(user.id, ...);
     } catch (notifError) {
       Sentry.captureException(notifError, {
         level: "warning",
         tags: { feature: "notification" },
         extra: { userId: user.id, action: "meal-plan-notification" },
       });
     }
     ```

  **For src/app/api/plans/workout/route.ts:**
  Apply the exact same pattern as above but:
  - Use `saveWorkoutPlan` instead of `saveMealPlan`
  - Feature tag: `"workout-plan-generation"`
  - Action: `"generate-workout-plan"`
  - Notification action: `"workout-plan-notification"`
  </action>
  <verify>
  Run `pnpm tsc --noEmit 2>&1 | head -30` — zero new errors from the two API routes.
  Grep for `getProfileById` in both route files to confirm extracted queries are used.
  Grep for `\.from\("profiles"\)` in both route files — must return zero results (queries extracted).
  Grep for `\.from\("initial_assessments"\)` in both route files — must return zero results.
  Grep for `console\.error` in both route files — must return zero results (replaced with Sentry).
  Grep for `Sentry.captureException` in both route files to confirm error logging.
  </verify>
  <done>
  Both plan API routes use extracted query functions (getProfileById, getAssessmentByUserId, getCheckInById, saveMealPlan/saveWorkoutPlan), log all errors to Sentry with userId/action/timestamp context, and have zero inline .from() queries for profile/assessment/check-in/plan-save.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero new errors
2. src/lib/supabase/queries/ directory exists with 5 files (profiles.ts, assessments.ts, check-ins.ts, plans.ts, index.ts)
3. All query functions throw AppError with descriptive codes
4. All query functions log to Sentry with feature tags
5. plans/meal/route.ts and plans/workout/route.ts use imported query functions (no inline .from() for profiles/assessments/check-ins/plan-save)
6. No `console.error` in any modified API routes
7. All catch blocks include Sentry.captureException with userId, action, timestamp
8. OneSignal fire-and-forget catches log to Sentry (not silently swallowed)
</verification>

<success_criteria>
- lib/supabase/queries/ directory exists with 5 typed query files
- getProfileById throws AppError("PROFILE_NOT_FOUND") and logs to Sentry
- getAssessmentByUserId throws AppError("ASSESSMENT_NOT_FOUND") and logs to Sentry
- getCheckInById returns null on failure (non-critical) and logs to Sentry
- saveMealPlan/saveWorkoutPlan throw on failure with Sentry logging
- Both plan API routes use extracted queries (zero inline .from() for these operations)
- Both plan API routes log errors to Sentry with context (not console.error)
- Notification failures logged to Sentry as warnings (not silently swallowed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-hardening-service-layer/04-02-SUMMARY.md`
</output>
